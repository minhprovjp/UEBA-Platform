# config.py
"""
================================================================================
BẢNG ĐIỀU KHIỂN TRUNG TÂM - FILE CẤU HÌNH VÀ HẰNG SỐ
================================================================================
File này chứa tất cả các giá trị cấu hình, đường dẫn, và các hằng số mặc định 
cho toàn bộ ứng dụng Phân Tích Hành Vi Người Dùng (UBA).
Việc tập trung tất cả các giá trị này vào một nơi giúp dễ dàng quản lý và thay đổi.
"""

# Import các thư viện cần thiết
from datetime import time as dt_time
from datetime import datetime
import os
from dotenv import load_dotenv

# ==============================================================================
# I. CẤU HÌNH BIẾN MÔI TRƯỜNG (ENVIRONMENT VARIABLES)
# ==============================================================================
# Lệnh này sẽ tìm và tải các biến từ một file có tên là `.env` trong thư mục gốc.
# `override=True` đảm bảo rằng giá trị trong file `.env` sẽ được ưu tiên.
load_dotenv(override=True)

# ==============================================================================
# II. CẤU HÌNH ĐƯỜNG DẪN VÀ FILE
# ==============================================================================
# Mục này định nghĩa tất cả các đường dẫn file mà ứng dụng sử dụng.

# Lấy đường dẫn đến thư mục gốc của project một cách tự động.
PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))

# --- CÁC ĐƯỜNG DẪN ĐƯỢC TÍNH TOÁN DỰA TRÊN THƯ MỤC GỐC ---
DATA_DIR = os.path.join(PROJECT_ROOT, "data")
STAGING_DATA_DIR = os.path.join(DATA_DIR, "staging")                    # Nơi chứa các file Parquet chờ xử lý
ARCHIVE_DATA_DIR = os.path.join(DATA_DIR, "archive")                    # (Tùy chọn) Nơi lưu trữ file đã xử lý
LOGS_DIR = os.path.join(PROJECT_ROOT, "logs")
ENGINE_DIR = os.path.join(PROJECT_ROOT, "engine")

# Thư mục để lưu trữ các file log đã phân tích bị không đồng bộ
MYSQL_MISMATCH_ARCHIVE_DIR = os.path.join(LOGS_DIR, "mismatch")


# Thêm URL PostgreSQL:
# Thay 'user:password' và 'db_name' cho đúng
DATABASE_URL = os.getenv("DATABASE_URL", "postgresql+psycopg2://uba_user:password@localhost:5432/uba_db")

# Hãy đảm bảo user/password này có quyền SELECT trên bảng mysql.general_log
MYSQL_LOG_DATABASE_URL = "mysql+mysqlconnector://uba_user:password@localhost:3306"

# SQLite cũ:
# DATABASE_URL = f"sqlite:///{os.path.join(DATA_DIR, 'app_database.db')}"

# --- ĐƯỜNG DẪN FILE CẤU HÌNH ĐỘNG ---
RULES_CONFIG_FILE_PATH = os.path.join(ENGINE_DIR, "rules_config.json")

# Đường dẫn ĐẦY ĐỦ đến file log thô của MySQL (ví dụ: general_log).
# Đây là file ĐẦU VÀO cho script `log_parser.py`.
# !! BẠN CẦN SỬA ĐƯỜNG DẪN NÀY CHO ĐÚNG VỚI MÁY CỦA BẠN TRONG SCRIPT PARSER !!
# `r""` (raw string) được dùng để tránh các lỗi liên quan đến dấu `\` trên Windows.
SOURCE_MYSQL_LOG_PATH = r"C:/mysql_logs/query.log"

# ------ Posstgresql log config ----------
SOURCE_POSTGRES_LOG_PATH = r'C:/psql_logs'

PARSED_POSTGRES_LOG_FILE_PATH = os.path.join(LOGS_DIR, "parsed_postgres_logs.parquet")

POSTGRES_PARSER_SCRIPT_PATH = os.path.join(ENGINE_DIR, "postgres_log_parser.py")

POSTGRES_STATE_FILE_PATH = os.path.join(LOGS_DIR, ".postgres_parser_state.json")

# ------ MySQL log config ---------
#SOURCE_MYSQL_LOG_PATH = r"C:/Users/IEUser/Downloads/tao_log/general_log.log"
SOURCE_MYSQL_LOG_PATH = r"C:/mysql_logs/query.log"
PARSED_MYSQL_LOG_PARQUET_PATH = os.path.join(LOGS_DIR, "parsed_mysql_logs.parquet")        # Tên file CSV sẽ được tạo ra sau khi `log_parser.py` chạy.
MYSQL_PARSER_SCRIPT_PATH = os.path.join(ENGINE_DIR, "mysql_log_parser.py")          # Tên file script thực hiện việc phân tích log.
META_FILE_PATH = MYSQL_PARSER_SCRIPT_PATH + ".meta"                                 # Tên file chứa thông tin metadata về lần parse cuối cùng (ví dụ: thời gian cập nhật).
MYSQL_STATE_FILE_PATH = os.path.join(LOGS_DIR, ".mysql_parser_state")               # Tên file chứa trạng thái của parser (ví dụ: vị trí cuối cùng đã đọc trong file log).

# --- Đường dẫn cho các mô hình Feedback và Module ---
MODELS_DIR = os.path.join(PROJECT_ROOT, "trained_models")                           # Thư mục chính để chứa tất cả các mô hình AI đã được huấn luyện.
USER_MODELS_DIR = os.path.join(MODELS_DIR, "user_models")                           # Thư mục con để chứa các mô hình AI được huấn luyện riêng cho từng người dùng.
FEEDBACK_FILE_PATH = os.path.join(PROJECT_ROOT, 'feedback.csv')                     # Tên file CSV để lưu trữ các phản hồi (feedback) từ người dùng.
VALID_MODELS_FILE_PATH = os.path.join(PROJECT_ROOT, 'valid_models.json')            # Tên file JSON để lưu danh sách các model AI đã được xác thực thành công.
ACTIVE_RESPONSE_AUDIT_LOG_PATH = os.path.join(PROJECT_ROOT, "active_response_audit.log")   # Tên file log cho các hành động phản ứng chủ động (Active Response)

# Tạo một danh sách tất cả các thư mục cần tồn tại và lặp qua để tạo chúng.
# Điều này đảm bảo rằng trước khi bất kỳ code nào khác chạy, môi trường đã sẵn sàng.
DIRECTORIES_TO_CREATE = [
    DATA_DIR, LOGS_DIR, ENGINE_DIR, MODELS_DIR, 
    USER_MODELS_DIR, MYSQL_MISMATCH_ARCHIVE_DIR,
    STAGING_DATA_DIR, ARCHIVE_DATA_DIR
]
for dir_path in DIRECTORIES_TO_CREATE:
    os.makedirs(dir_path, exist_ok=True)

# Tên file CSV sẽ được tạo ra sau khi `log_parser.py` chạy.
PARSED_MYSQL_LOG_PARQUET_PATH = os.path.join(LOGS_DIR, "parsed_mysql_logs.parquet")
STAGING_DATA_DIR = os.path.join(DATA_DIR, "staging")   # Nơi chứa các file Parquet chờ xử lý
ARCHIVE_DATA_DIR = os.path.join(DATA_DIR, "archive")   # (Tùy chọn) Nơi lưu trữ file đã xử lý

# --- Đường dẫn cho các mô hình AI và Feedback ---

# Thư mục chính để chứa tất cả các mô hình AI đã được huấn luyện.
MODELS_DIR = "trained_models"

# Thư mục con để chứa các mô hình AI được huấn luyện riêng cho từng người dùng.
USER_MODELS_DIR = os.path.join(MODELS_DIR, "user_models")

# Tên file CSV để lưu trữ các phản hồi (feedback) từ người dùng.
FEEDBACK_FILE_PATH = 'feedback.csv'

# Tên file JSON để lưu danh sách các model AI đã được xác thực thành công.
VALID_MODELS_FILE_PATH = 'valid_models.json'

# Tên file log cho các hành động phản ứng chủ động (Active Response)
ACTIVE_RESPONSE_AUDIT_LOG_PATH = os.path.join(PROJECT_ROOT, "active_response_audit.log")  

SUSPICIOUS_FUNCTIONS = ['sleep', 'benchmark', 'load_file', 'updatexml', 'extractvalue']
PRIVILEGE_COMMANDS = ['grant', 'revoke', 'create user', 'drop user', 'alter user']

# ==============================================================================
# III. CẤU HÌNH CÁC DỊCH VỤ NGOÀI VÀ HỆ THỐNG
# ==============================================================================

# --- 1. Cấu hình Theo dõi File ---
# Thời gian (giây) mà ứng dụng sẽ chờ giữa mỗi lần kiểm tra file log.

ENGINE_SLEEP_INTERVAL_SECONDS = 60

# --- 2. Cấu hình Server Ollama ---
DEFAULT_OLLAMA_HOST = 'http://localhost:11434'  # Địa chỉ mặc định của server Ollama.
DEFAULT_OLLAMA_MODEL = 'seneca'                 # Tên model mặc định sẽ được sử dụng.
OLLAMA_TIMEOUT_SECONDS = 3600                   # Thời gian chờ tối đa (giây) khi gọi AI (1 giờ).

# --- 3. Cấu hình Cảnh báo qua Email ---
LAST_EMAIL_SENT_TIME = datetime.min
EMAIL_COOLDOWN_SECONDS = 180  # x second gửi 1 lần
PENDING_VIOLATIONS = []       # Buffer chứa các vi phạm đang chờ gửi

# Đọc các giá trị từ file .env đã được load ở đầu file.
# os.getenv("KEY", "default_value") sẽ lấy giá trị của biến môi trường "KEY",
# nếu không tìm thấy, nó sẽ sử dụng "default_value".
ALERT_EMAIL_SETTINGS = {
    # Địa chỉ máy chủ SMTP (ví dụ: 'smtp.gmail.com').
    "smtp_server": os.getenv("SMTP_SERVER"),
    
    # Cổng SMTP (thường là 587 cho TLS hoặc 465 cho SSL).
    "smtp_port": os.getenv("SMTP_PORT"),
    
    # Địa chỉ email người gửi.
    "sender_email": os.getenv("SENDER_EMAIL"),
    
    # Mật khẩu ứng dụng của email người gửi (không phải mật khẩu đăng nhập chính).
    "sender_password": os.getenv("SENDER_PASSWORD"),
    
    # Danh sách người nhận chính (To), được phân tách bằng dấu phẩy trong file .env.
    # Code sẽ tự động tách chuỗi, loại bỏ khoảng trắng và các email rỗng.
    "to_recipients": [email.strip() for email in os.getenv("TO_RECIPIENTS", "").split(",") if email.strip()],
    
    # Danh sách người nhận ẩn danh (BCC).
    "bcc_recipients": [email.strip() for email in os.getenv("BCC_RECIPIENTS", "").split(",") if email.strip()]
}

# ==== REDIS / REALTIME PIPELINE ====
# --- Redis & Streams ---
REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379/0")
REDIS_PROFILE_KEY_PREFIX = "uba:profile:"
# Streams đặt tên rõ để dễ mở rộng đa DBMS sau này
REDIS_STREAM_LOGS = os.getenv("REDIS_STREAM_LOGS", "uba:logs")
REDIS_GROUP_ENGINE = os.getenv("REDIS_GROUP_ENGINE", "uba_engine")
REDIS_CONSUMER_NAME = os.getenv("REDIS_CONSUMER_NAME", os.getenv("COMPUTERNAME", "consumer"))

# Kích thước micro-batch cho engine (tuỳ chọn)
ENGINE_BATCH_MAX_MESSAGES = int(os.getenv("ENGINE_BATCH_MAX_MESSAGES", "10000"))
ENGINE_BATCH_MAX_BLOCK_MS  = int(os.getenv("ENGINE_BATCH_MAX_BLOCK_MS", "1000"))  # 15s block chờ

# Các Stream cần lắng nghe (chỉ MySQL)
STREAMS = {f"{REDIS_STREAM_LOGS}:mysql": ">"} 

# ====== 4. Cấu hình Phản ứng Chủ động (Active Response) ======
# Ngưỡng (số lượng vi phạm) để kích hoạt khóa tài khoản
ACTIVE_RESPONSE_TRIGGER_THRESHOLD = 5 # Ví dụ: Khóa user nếu có 5 vi phạm trở lên

# Đọc cấu hình admin MySQL từ .env
ACTIVE_RESPONSE_SETTINGS = {
    "mysql_host": os.getenv("MYSQL_ADMIN_HOST"),
    "mysql_port": os.getenv("MYSQL_ADMIN_PORT"),
    "mysql_user": os.getenv("MYSQL_ADMIN_USER"),
    "mysql_password": os.getenv("MYSQL_ADMIN_PASSWORD"),
}